<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QR Code Streaming Generator</title>
  <style>
    /* Basic reset and styling */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      line-height: 1.6;
      color: #e0e0e0;
      background-color: #121212;
      padding: 20px;
      height: 100vh;
      overflow: hidden;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #f0f0f0;
    }
    
    .main-layout {
      display: flex;
      flex-direction: row;
      height: calc(100vh - 80px);
    }
    
    /* Responsive layout */
    @media (max-width: 960px) {
      .main-layout {
        flex-direction: column;
      }
      
      .container {
        width: 100% !important;
        min-width: 100% !important;
        margin-bottom: 20px;
      }
      
      .qr-display {
        width: 100% !important;
        height: auto !important;
      }
    }
    
    .container {
      width: 20%;
      min-width: 250px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      overflow-y: auto;
      padding-right: 20px;
    }
    
    .control-item {
      display: flex;
      flex-direction: column;
      background-color: #1e1e1e;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }
    
    .control-item label {
      color: #ccc;
      margin-bottom: 10px;
      font-weight: bold;
    }
    
    #slice-size {
      width: 80px;
      padding: 8px;
      border: 1px solid #333;
      border-radius: 4px;
      background-color: #2c2c2c;
      color: #e0e0e0;
      text-align: center;
    }
    
    #fps-input {
      width: 60px;
      padding: 8px;
      border: 1px solid #333;
      border-radius: 4px;
      background-color: #2c2c2c;
      color: #e0e0e0;
      text-align: center;
    }
    
    .fps-control {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .fps-buttons {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .fps-row {
      display: flex;
      gap: 8px;
    }
    
    .fps-button {
      width: 54px;
      height: 32px;
      background-color: #2c2c2c;
      border: 1px solid #555;
      color: #e0e0e0;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .fps-button.active {
      background-color: #3498db;
      border-color: #3498db;
      color: white;
    }
    
    .file-input-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-color: #1e1e1e;
      border: 2px dashed #555;
      border-radius: 8px;
      padding: 20px 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      margin-bottom: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }
    
    .file-input-container.dragging {
      border-color: #3498db;
      background-color: rgba(52, 152, 219, 0.1);
    }
    
    .file-input-container:hover {
      border-color: #3498db;
    }
    
    .file-input {
      display: none;
    }
    
    .info-text {
      color: #aaa;
      margin-top: 8px;
      font-size: 0.9em;
    }
    
    .qr-display {
      width: 80%;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
      background-color: #1e1e1e;
      border-radius: 8px;
    }
    
    .qr-container {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      aspect-ratio: 1/1;
    }
    
    .qr-code {
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      max-width: min(80vh, 80vw);
      max-height: min(80vh, 80vw);
      aspect-ratio: 1/1;
    }
    
    .qr-code svg {
      width: 100%;
      height: 100%;
      background-color: white;
      border-radius: 8px;
      aspect-ratio: 1/1;
    }
    
    .collapsible {
      background-color: #1e1e1e;
      border-radius: 8px;
      margin-top: 10px;
      overflow: hidden;
      margin-bottom: 10px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }
    
    .collapsible-header {
      padding: 10px 15px;
      background-color: #2c2c2c;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .collapsible-content {
      padding: 15px;
      display: block;
    }
    
    .info-grid {
      display: grid;
      grid-template-columns: 100px 1fr;
      gap: 8px;
      font-family: monospace;
      font-size: 14px;
      overflow-x: auto;
      white-space: nowrap;
    }
    
    .info-label {
      color: #aaa;
    }
    
    .hidden {
      display: none;
    }
    
    .button {
      padding: 10px 20px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.2s;
    }
    
    .button:hover {
      background-color: #2980b9;
    }
    
    .button:disabled {
      background-color: #555;
      cursor: not-allowed;
    }

    .dropzone-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      display: none;
    }

    .dropzone-content {
      background-color: transparent;
      border: 4px dashed white;
      border-radius: 8px;
      width: 80%;
      height: 80%;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .dropzone-message {
      color: white;
      font-size: 24px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>QR Code Streaming Generator</h1>
  
  <div class="main-layout">
    <div class="container">
      <div id="file-input-area" class="file-input-container">
        <p>Click to select a file or drag and drop</p>
        <p class="info-text">Any file type supported</p>
        <input type="file" id="file-input" class="file-input">
      </div>
      
      <div class="control-item">
        <label for="slice-size">Slice Size:</label>
        <input type="number" id="slice-size" min="100" max="2000" value="1000">
      </div>
      
      <div class="control-item">
        <label for="fps-input">FPS:</label>
        <div class="fps-control">
          <div class="fps-buttons">
            <div class="fps-row">
              <button class="fps-button" data-fps="5">5 Hz</button>
              <button class="fps-button active" data-fps="10">10 Hz</button>
            </div>
            <div class="fps-row">
              <button class="fps-button" data-fps="15">15 Hz</button>
              <button class="fps-button" data-fps="20">20 Hz</button>
            </div>
          </div>
          <input type="number" id="fps-input" min="1" max="60" step="1" value="10">
        </div>
      </div>
      
      <div class="collapsible">
        <div class="collapsible-header" id="info-header">
          <span>QR Code Information</span>
          <span>▼</span>
        </div>
        <div class="collapsible-content" id="info-content">
          <div class="info-grid">
            <span class="info-label">Indices:</span>
            <span id="block-indices">-</span>
            
            <span class="info-label">Total Blocks:</span>
            <span id="block-total">-</span>
            
            <span class="info-label">Bytes:</span>
            <span id="block-bytes">-</span>
            
            <span class="info-label">Bitrate:</span>
            <span id="block-bitrate">-</span>
            
            <span class="info-label">Frame Count:</span>
            <span id="frame-count">-</span>
            
            <span class="info-label">FPS:</span>
            <span id="actual-fps">-</span>
            
            <span class="info-label">Filename:</span>
            <span id="file-name">-</span>
            
            <span class="info-label">Content Type:</span>
            <span id="content-type">-</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="qr-display">
      <div class="qr-container">
        <div id="qr-code" class="qr-code"></div>
      </div>
    </div>
  </div>

  <div class="dropzone-overlay" id="dropzone-overlay">
    <div class="dropzone-content">
      <div class="dropzone-message">Drop File Here</div>
    </div>
  </div>

  <!-- External libraries -->
  <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>

  <script>
    // QR Code generation functions
    /**
     * Generate QR code SVG for the given data
     * @param {string} data - Data to encode in QR code
     * @param {Object} options - Options for QR code generation
     * @returns {string} - SVG string representation of QR code
     */
    function generateQRCodeSVG(data, options = {}) {
      const typeNumber = 0; // Auto-detect size
      const errorCorrectionLevel = options.ecLevel || 'M';
      const qr = qrcode(typeNumber, errorCorrectionLevel);
      qr.addData(data);
      qr.make();
      
      // Create SVG with responsive dimensions
      const cellSize = options.cellSize || 4;
      const margin = options.border || 4;
      const svgString = qr.createSvgTag(cellSize, margin);
      
      // Parse and clean up SVG to remove fixed width/height
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
      const svgElement = svgDoc.documentElement;
      
      // Remove fixed dimensions to allow proper scaling
      svgElement.removeAttribute("width");
      svgElement.removeAttribute("height");
      svgElement.setAttribute("viewBox", svgElement.getAttribute("viewBox"));
      svgElement.setAttribute("preserveAspectRatio", "xMidYMid meet");
      
      return new XMLSerializer().serializeToString(svgElement);
    }

    /**
     * CRC32 lookup table
     */
    const CRC_TABLE = (() => {
      const table = new Uint32Array(256);
      for (let i = 0; i < 256; i++) {
        let crc = i;
        for (let j = 0; j < 8; j++) {
          crc = (crc & 1) ? (0xEDB88320 ^ (crc >>> 1)) : (crc >>> 1);
        }
        table[i] = crc;
      }
      return table;
    })();

    /**
     * Calculate CRC32 checksum for a buffer
     * @param {Uint8Array} buf - Buffer to calculate checksum for
     * @returns {number} - CRC32 checksum
     */
    function crc32(buf) {
      let crc = 0xFFFFFFFF;
      for (let i = 0; i < buf.length; i++) {
        crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ buf[i]) & 0xFF];
      }
      return (crc ^ 0xFFFFFFFF) >>> 0;
    }

    /**
     * Get the checksum for a data buffer and its slice count
     * @param {Uint8Array} data - Data buffer
     * @param {number} k - Number of slices
     * @returns {number} - Checksum value
     */
    function getChecksum(data, k) {
      return crc32(data) ^ k;
    }

    /**
     * Merge multiple Uint8Array into a single Uint8Array
     * Each chunk is prefixed with a 4-byte Uint32 to store the length of the chunk
     * @param {Uint8Array[]} arrays - Arrays to merge
     * @returns {Uint8Array} - Merged array
     */
    function mergeUint8Arrays(arrays) {
      const totalLength = arrays.reduce((sum, arr) => sum + arr.length + 4, 0); // 4 bytes for length (Uint32)
      
      const mergedArray = new Uint8Array(totalLength);
      let offset = 0;
      
      arrays.forEach((arr) => {
        const length = arr.length;
        // Store the length as a 4-byte Uint32
        mergedArray[offset++] = (length >> 24) & 0xFF;
        mergedArray[offset++] = (length >> 16) & 0xFF;
        mergedArray[offset++] = (length >> 8) & 0xFF;
        mergedArray[offset++] = length & 0xFF;
        
        // Copy data
        mergedArray.set(arr, offset);
        offset += length;
      });
      
      return mergedArray;
    }

    /**
     * Convert a string to a Uint8Array
     * @param {string} str - String to convert
     * @returns {Uint8Array} - Resulting array
     */
    function stringToUint8Array(str) {
      const data = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        data[i] = str.charCodeAt(i);
      }
      return data;
    }

    /**
     * Append file header metadata to a buffer
     * @param {Uint8Array} data - Buffer data
     * @param {Object} meta - File metadata (filename, contentType)
     * @returns {Uint8Array} - Buffer with file metadata
     */
    function appendFileHeaderMetaToBuffer(data, meta) {
      const json = JSON.stringify(meta);
      const metaBuffer = stringToUint8Array(json);
      return mergeUint8Arrays([metaBuffer, data]);
    }

    /**
     * Convert a block to binary format
     * @param {Object} block - Block to convert
     * @returns {Uint8Array} - Binary representation
     */
    function blockToBinary(block) {
      const { k, bytes, checksum, indices, data } = block;
      const header = new Uint32Array([
        indices.length,
        ...indices,
        k,
        bytes,
        checksum,
      ]);

      const binary = new Uint8Array(header.length * 4 + data.length);
      let offset = 0;
      binary.set(new Uint8Array(header.buffer), offset);
      offset += header.length * 4;
      binary.set(data, offset);

      return binary;
    }

    /**
     * Convert binary data to base64
     * @param {Uint8Array} binary - Binary data
     * @returns {string} - Base64 string
     */
    function toBase64(binary) {
      const bytes = new Uint8Array(binary);
      let base64 = '';
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      const byteLength = bytes.byteLength;
      const byteRemainder = byteLength % 3;
      const mainLength = byteLength - byteRemainder;

      let a, b, c, d;
      let chunk;

      // Main loop deals with bytes in chunks of 3
      for (let i = 0; i < mainLength; i = i + 3) {
        // Combine the three bytes into a single integer
        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

        // Use bitmasks to extract 6-bit segments from the triplet
        a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
        b = (chunk & 258048) >> 12; // 258048 = (2^6 - 1) << 12
        c = (chunk & 4032) >> 6; // 4032 = (2^6 - 1) << 6
        d = chunk & 63; // 63 = 2^6 - 1

        // Convert the raw binary segments to the appropriate ASCII encoding
        base64 += chars[a] + chars[b] + chars[c] + chars[d];
      }

      // Deal with the remaining bytes
      if (byteRemainder === 1) {
        chunk = bytes[mainLength];
        a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2
        b = (chunk & 3) << 4; // 3 = 2^2 - 1
        base64 += chars[a] + chars[b] + '==';
      } else if (byteRemainder === 2) {
        chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];
        a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
        b = (chunk & 1008) >> 4; // 1008 = (2^6 - 1) << 4
        c = (chunk & 15) << 2; // 15 = 2^4 - 1
        base64 += chars[a] + chars[b] + chars[c] + '=';
      }

      return base64;
    }

    /**
     * Slice data into blocks of specified size
     * @param {Uint8Array} data - Data to slice
     * @param {number} blockSize - Size of each block
     * @returns {Uint8Array[]} - Array of data blocks
     */
    function sliceData(data, blockSize) {
      const blocks = [];
      for (let i = 0; i < data.length; i += blockSize) {
        const block = new Uint8Array(blockSize);
        block.set(data.slice(i, i + blockSize));
        blocks.push(block);
      }
      return blocks;
    }

    /**
     * Use Ideal Soliton Distribution to select degree
     * @param {number} k - Number of blocks
     * @returns {number} - Selected degree
     */
    function getRandomDegree(k) {
      const probabilities = Array(k).fill(0);
      
      // Calculate the probabilities of the Ideal Soliton Distribution
      probabilities[0] = 1 / k; // P(1) = 1/k
      for (let d = 2; d <= k; d++) {
        probabilities[d - 1] = 1 / (d * (d - 1));
      }
      
      // Accumulate the probabilities to generate the cumulative distribution
      const cumulativeProbabilities = [];
      let sum = 0;
      for (const p of probabilities) {
        sum += p;
        cumulativeProbabilities.push(sum);
      }
      
      // Generate a random number between [0,1] and select the corresponding degree
      const randomValue = Math.random();
      for (let i = 0; i < cumulativeProbabilities.length; i++) {
        if (randomValue < cumulativeProbabilities[i]) {
          return i + 1;
        }
      }
      
      return k; // Theoretically, this line should never be reached
    }

    /**
     * Randomly select indices of degree number of original data blocks
     * @param {number} k - Number of blocks
     * @param {number} degree - Degree to select
     * @returns {number[]} - Selected indices
     */
    function getRandomIndices(k, degree) {
      const indices = new Set();
      while (indices.size < degree) {
        const randomIndex = Math.floor(Math.random() * k);
        indices.add(randomIndex);
      }
      return Array.from(indices);
    }

    /**
     * LtEncoder class for encoding data using Luby Transform
     */
    class LtEncoder {
      /**
       * Create a new LtEncoder
       * @param {Uint8Array} data - Data to encode
       * @param {number} sliceSize - Size of each slice
       * @param {boolean} compress - Whether to compress data
       */
      constructor(data, sliceSize, compress = true) {
        this.data = data;
        this.sliceSize = sliceSize;
        this.compress = compress;
        
        // Compress data if needed
        this.compressed = compress ? pako.deflate(data) : data;
        
        // Slice the data
        this.indices = sliceData(this.compressed, sliceSize);
        this.k = this.indices.length;
        this.checksum = getChecksum(this.data, this.k);
        this.bytes = this.compressed.length;
      }
      
      /**
       * Create a block from selected indices
       * @param {number[]} indices - Indices to use
       * @returns {Object} - Created block
       */
      createBlock(indices) {
        const data = new Uint8Array(this.sliceSize);
        for (const index of indices) {
          const indicesIndex = this.indices[index];
          for (let i = 0; i < this.sliceSize; i++) {
            data[i] = data[i] ^ indicesIndex[i];
          }
        }
        
        return {
          k: this.k,
          bytes: this.bytes,
          checksum: this.checksum,
          indices,
          data,
        };
      }
      
      /**
       * Generator function that creates an infinite stream of encoded blocks
       */
      *fountain() {
        while (true) {
          const degree = getRandomDegree(this.k);
          const selectedIndices = getRandomIndices(this.k, degree);
          yield this.createBlock(selectedIndices);
        }
      }
    }

    /**
     * Create a new LtEncoder
     * @param {Uint8Array} data - Data to encode
     * @param {number} sliceSize - Size of each slice
     * @param {boolean} compress - Whether to compress data
     * @returns {LtEncoder} - Created encoder
     */
    function createEncoder(data, sliceSize, compress = true) {
      return new LtEncoder(data, sliceSize, compress);
    }

    // UI interaction code
    document.addEventListener('DOMContentLoaded', () => {
      // Elements
      const fileInputArea = document.getElementById('file-input-area');
      const fileInput = document.getElementById('file-input');
      const sliceSizeInput = document.getElementById('slice-size');
      const fpsInput = document.getElementById('fps-input');
      const fpsButtons = document.querySelectorAll('.fps-button');
      const qrCodeElement = document.getElementById('qr-code');
      const dropzoneOverlay = document.getElementById('dropzone-overlay');
      const infoHeader = document.getElementById('info-header');
      const infoContent = document.getElementById('info-content');
      
      // Stats elements
      const blockIndicesElement = document.getElementById('block-indices');
      const blockTotalElement = document.getElementById('block-total');
      const blockBytesElement = document.getElementById('block-bytes');
      const blockBitrateElement = document.getElementById('block-bitrate');
      const frameCountElement = document.getElementById('frame-count');
      const actualFpsElement = document.getElementById('actual-fps');
      const fileNameElement = document.getElementById('file-name');
      const contentTypeElement = document.getElementById('content-type');
      
      // State variables
      let encoder = null;
      let generator = null;
      let animationFrameId = null;
      let frameCount = 0;
      let lastFrameTime = 0;
      let renderTime = 0;
      let currentBlock = null;
      let filename = '';
      let contentType = '';
      
      // Initialize FPS display
      let currentFps = 10;
      
      // Show collapsible content by default
      infoContent.style.display = 'block';
      
      // Setup file input click handler
      fileInputArea.addEventListener('click', () => {
        fileInput.click();
      });
      
      // Setup file input change handler
      fileInput.addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (file) {
          await processFile(file);
        }
      });
      
      // FPS buttons handler
      fpsButtons.forEach(button => {
        button.addEventListener('click', () => {
          // Remove active class from all buttons
          fpsButtons.forEach(btn => btn.classList.remove('active'));
          // Add active class to the clicked button
          button.classList.add('active');
          
          // Update the fps input value
          const fps = parseInt(button.dataset.fps);
          currentFps = fps;
          fpsInput.value = fps;
        });
      });
      
      // FPS input handler
      fpsInput.addEventListener('change', () => {
        let fps = parseInt(fpsInput.value);
        
        // Validate fps value
        if (isNaN(fps) || fps < 1 || fps > 60 || !Number.isInteger(fps)) {
          fps = 10;
          fpsInput.value = 10;
        }
        
        currentFps = fps;
        
        // Update active button if fps matches a preset
        fpsButtons.forEach(btn => {
          btn.classList.remove('active');
          if (parseInt(btn.dataset.fps) === fps) {
            btn.classList.add('active');
          }
        });
      });
      
      // Setup drag and drop handlers
      let dragCounter = 0;
      
      window.addEventListener('dragenter', (event) => {
        event.preventDefault();
        dragCounter++;
        dropzoneOverlay.style.display = 'flex';
      });
      
      window.addEventListener('dragleave', (event) => {
        event.preventDefault();
        dragCounter--;
        if (dragCounter === 0) {
          dropzoneOverlay.style.display = 'none';
        }
      });
      
      window.addEventListener('dragover', (event) => {
        event.preventDefault();
      });
      
      window.addEventListener('drop', async (event) => {
        event.preventDefault();
        dragCounter = 0;
        dropzoneOverlay.style.display = 'none';
        
        if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
          const file = event.dataTransfer.files[0];
          await processFile(file);
        }
      });
      
      // Info header toggle
      infoHeader.addEventListener('click', () => {
        if (infoContent.style.display === 'block') {
          infoContent.style.display = 'none';
          infoHeader.querySelector('span:last-child').textContent = '▼';
        } else {
          infoContent.style.display = 'block';
          infoHeader.querySelector('span:last-child').textContent = '▲';
        }
      });
      
      // Process the selected file
      async function processFile(file) {
        if (!file) return;
        
        // Stop any existing animation
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        
        // Reset frame count
        frameCount = 0;
        
        // Set file info
        filename = file.name;
        contentType = file.type || 'application/octet-stream';
        fileNameElement.textContent = filename;
        contentTypeElement.textContent = contentType;
        
        try {
          // Read file as ArrayBuffer
          const buffer = await file.arrayBuffer();
          
          // Append file metadata
          const data = appendFileHeaderMetaToBuffer(new Uint8Array(buffer), {
            filename,
            contentType,
          });
          
          // Create encoder with the current slice size
          const sliceSize = parseInt(sliceSizeInput.value, 10);
          encoder = createEncoder(data, sliceSize);
          
          // Create generator
          generator = encoder.fountain();
          
          // Start animation
          startAnimation();
        } catch (error) {
          console.error('Error processing file:', error);
          alert(`Error processing file: ${error.message}`);
        }
      }
      
      // Start the animation loop
      function startAnimation() {
        lastFrameTime = performance.now();
        animationLoop();
      }
      
      // Animation loop
      function animationLoop() {
        const now = performance.now();
        const frameInterval = 1000 / currentFps;
        
        // Check if it's time for a new frame
        if (now - lastFrameTime >= frameInterval) {
          renderTime = now - lastFrameTime;
          lastFrameTime = now;
          
          // Generate a new block
          const block = generator.next().value;
          currentBlock = block;
          frameCount++;
          
          // Convert block to binary and then to Base64
          const binary = blockToBinary(block);
          const base64 = toBase64(binary);
          
          // Generate QR code
          const svg = generateQRCodeSVG(base64, {
            ecLevel: 'M'
          });
          
          // Update QR code display
          qrCodeElement.innerHTML = svg;
          
          // Update info display
          updateInfoDisplay();
        }
        
        // Continue animation loop
        animationFrameId = requestAnimationFrame(animationLoop);
      }
      
      // Update information display
      function updateInfoDisplay() {
        if (!currentBlock) return;
        
        // Format KB with two decimal places
        const kbFormatter = (bytes) => (bytes / 1024).toFixed(2) + ' KB';
        
        // Calculate actual FPS
        const actualFps = 1000 / renderTime;
        
        // Update elements
        blockIndicesElement.textContent = currentBlock.indices.join(', ');
        blockTotalElement.textContent = currentBlock.k;
        blockBytesElement.textContent = kbFormatter(currentBlock.bytes);
        blockBitrateElement.textContent = (currentBlock.bytes / 1024 * actualFps).toFixed(2) + ' KBps';
        frameCountElement.textContent = frameCount;
        actualFpsElement.textContent = actualFps.toFixed(2);
      }
    });
  </script>
</body>
</html>
